(() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b)) {
        if (__propIsEnum.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      }
    return a;
  };

  // src/js/include/config.js
  var defaultConfig = {
    "idEmbedContainer": "embed-container",
    "idPosterContainer": "poster-container",
    "idSpinnerContainer": "spinner-container",
    "idPosterImg": "poster-img",
    "idBtnPlay": "btn-play",
    "activeIframeClass": "isactive",
    "textVideoTitle": "Video da Youtube",
    "textVideoDescription": "Guarda questo video incorporato nel sito da Youtube",
    "textMissingVideoId": "ID video errato o mancante",
    "textBtn": "Riproduci",
    "textVideo": "video",
    "spinnerColor": "#ff0000",
    "videoStartAt": 0,
    "posterQuality": "hqdefault"
  };

  // src/js/include/setStyle.js
  var setStyle = () => {
    const stylesheet = new CSSStyleSheet();
    stylesheet.replaceSync(`

		:host,
		:host *,
		:host *::before,
		:host *::after
		{
			box-sizing: border-box;
		}

		:host
		{
			contain: content;
			display: block;
			width: 100%;
			aspect-ratio: var(--aspect-ratio);
			--aspect-ratio: var(--embed-youtube-aspect-ratio, 16 / 9);
			--aspect-ratio-short: var(--embed-youtube-aspect-ratio-short, 9 / 16);
		}

		@media (max-width: 40em)
		{
			:host([short])
			{
				aspect-ratio: var(--aspect-ratio-short);
			}
		}

		#embed-container
		{
			position: relative;
			width: 100%;
			height: 100%;
			aspect-ratio: 16 / 9;
			overflow: hidden;
			cursor: pointer;
		}

		#embed-container.isactive::before,
		#embed-container.isactive > #btn-play
		{
			display: none;
		}

		iframe,
		#poster-img
		{
			position: absolute;
			width: 100%;
			height: 100%;
			inset: 0;
		}

		iframe
		{
			border: 0;
		}

		#poster-img
		{
			object-fit: cover;
			box-sizing: border-box;
		}

		#btn-play
		{
			width: 68px;
			height: 48px;
			z-index: 1;
			border: 0;
			background-color: transparent;
			background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 68 48"><path d="M66.52 7.74c-.78-2.93-2.49-5.41-5.42-6.19C55.79.13 34 0 34 0S12.21.13 6.9 1.55c-2.93.78-4.63 3.26-5.42 6.19C.06 13.05 0 24 0 24s.06 10.95 1.48 16.26c.78 2.93 2.49 5.41 5.42 6.19C12.21 47.87 34 48 34 48s21.79-.13 27.1-1.55c2.93-.78 4.64-3.26 5.42-6.19C67.94 34.95 68 24 68 24s-.06-10.95-1.48-16.26z" fill="red"/><path d="M45 24 27 14v20" fill="white"/></svg>');
			background-repeat: no-repeat;
  			background-position: center;
  			background-size: 100% 100%;
		}

		#btn-play:before
		{
			content: "";
			border-style: solid;
			border-width: 10px 0 10px 16px;
			border-color: transparent transparent transparent #fff;
		}

		#btn-play,
		#btn-play:before,
		#error-message
		{
			position: absolute;
			top: 50%;
			left: 50%;
			text-align: center;
			transform: translate3d(-50%, -50%, 0);
			cursor: inherit;
		}

		#error-message
		{
			width: 100%;
		}

		.isactive
		{
			cursor: unset;
		}

		#spinner-container
		{
			position: absolute;
			top: 50%;
			left: 50%;
			transform: translate3d(-50%, -50%, 0);
		}
	`);
    return stylesheet;
  };

  // src/js/include/initShadowDom.js
  var initShadowDom = (context) => {
    const { config } = context;
    context.attachShadow({
      "mode": "open"
    });
    context.shadowRoot.adoptedStyleSheets = [setStyle()];
    context.shadowRoot.innerHTML = `

		<div id="${config.idEmbedContainer}">
			<div id="${config.idSpinnerContainer}" part="spinner">
				<svg width="60" height="60" viewBox="0 0 44 44">
					<circle cx="50%" cy="50%" r="20" fill="none" stroke="#E5E7EB" stroke-width="4"></circle>
					<circle cx="50%" cy="50%" r="20" fill="none" stroke="${config.spinnerColor}" stroke-width="4" stroke-dasharray="125.6" stroke-dashoffset="125.6">
						<animate attributeName="stroke-dashoffset" values="125.6;0" dur="1.5s" repeatCount="indefinite"></animate>
					</circle>
				</svg>
			</div>
			<picture id="${config.idPosterContainer}">
				<img id="${config.idPosterImg}" part="poster" referrerpolicy="origin" loading="lazy" alt="">
			</picture>
			<button id="${config.idBtnPlay}" part="play-button" hidden></button>
		</div>
	`;
    context.domContainer = context.shadowRoot.getElementById(config.idEmbedContainer);
    context.domPosterContainer = context.shadowRoot.getElementById(config.idPosterContainer);
    context.domImgPoster = context.shadowRoot.getElementById(config.idPosterImg);
    context.domPlayButton = context.shadowRoot.getElementById(config.idBtnPlay);
  };

  // src/js/include/util.js
  var preloadConnection = /* @__PURE__ */ (() => {
    let isPreconnected = false;
    const addPrefetch = (type, url) => {
      const linkElem = document.createElement("link");
      linkElem.rel = type;
      linkElem.href = url;
      linkElem.crossOrigin = "true";
      document.head.append(linkElem);
    };
    return (context) => {
      if (isPreconnected || context.noPreconnect || context.globalNoPreconnect) return;
      addPrefetch("preconnect", "https://i.ytimg.com/");
      addPrefetch("preconnect", "https://s.ytimg.com");
      if (!context.noCookie) {
        addPrefetch("preconnect", "https://www.youtube.com");
        addPrefetch("preconnect", "https://www.google.com");
        addPrefetch("preconnect", "https://googleads.g.doubleclick.net");
        addPrefetch("preconnect", "https://static.doubleclick.net");
      } else {
        addPrefetch("preconnect", "https://www.youtube-nocookie.com");
      }
      isPreconnected = true;
    };
  })();
  var normalizeVideoId = (rawid) => {
    if (!rawid) return "";
    const videoId = decodeURIComponent(rawid);
    const isUrl = /^(?:https?:\/\/|www\.)/.test(rawid);
    if (isUrl) {
      if (videoId.includes("youtube.com") || videoId.includes("youtu.be")) {
        try {
          const url = new URL(videoId);
          const segments = url.pathname.split("/");
          return segments.pop() || "";
        } catch (e) {
          return "";
        }
      }
      return "";
    }
    return videoId;
  };
  var missingVideoId = (context) => {
    if (!context.videoId || context.videoId === "") {
      hideElem(context.shadowRoot.getElementById(context.config.idSpinnerContainer), true);
      const h2 = document.createElement("h2");
      h2.id = "error-message";
      h2.textContent = context.config.textMissingVideoId;
      context.domContainer.appendChild(h2);
      return true;
    }
    return false;
  };
  var injectSchema = (context) => {
    const { config } = context;
    const { videoId } = context;
    const videoTitle = context.videoTitle || config.textVideoTitle;
    const description = context.description || config.textVideoDescription;
    const embedTarget = context.playlistId ? `?listType=playlist&list=${context.playlistId}` : `${videoId}`;
    const script = document.createElement("script");
    script.id = `json-${videoId}`;
    script.type = "application/ld+json";
    script.text = JSON.stringify({
      "@context": "https://schema.org",
      "@type": "VideoObject",
      "name": `${videoTitle}`,
      "description": `${description}`,
      "thumbnailUrl": `https://i.ytimg.com/vi/${videoId}/hqdefault.jpg`,
      "contentUrl": `https://www.youtube.com/watch?v=${videoId}`,
      "embedUrl": `https://www.youtube.com/embed/${embedTarget}`
    });
    context.prepend(script);
  };
  var setLabel = (context) => {
    const { config } = context;
    if (context.playText && context.videoTitle) {
      return `${context.playText} ${context.videoTitle}`;
    }
    if (context.playText) {
      return context.playText;
    }
    if (context.videoTitle) {
      return `${config.textBtn} ${context.videoTitle}`;
    }
    return `${config.textBtn} ${config.textVideo}`;
  };
  var hideElem = (btn, hide = true, timeout = 250) => {
    if (hide) {
      btn.hidden = true;
    } else {
      setTimeout(() => {
        btn.hidden = false;
      }, timeout);
    }
  };

  // src/js/embed-youtube.js
  /**
  * @preserve
  * Filename: embed-youtube.js
  *
  * Created: 05/05/2025 (12:08:23)
  * Created by: Lorenzo Saibal Forti <lorenzo.forti@gmail.com>
  *
  * Last update: 22/07/2025 (15:15:47)
  * Updated by: Lorenzo Saibal Forti <lorenzo.forti@gmail.com>
  *
  * Copyleft: 2025 - Tutti i diritti riservati
  *
  * Comments:
  */
  (() => {
    "use strict";
    const globalParamHook = document.currentScript || document.getElementsByTagName("body")[0];
    class embedYouTube extends HTMLElement {
      constructor() {
        super();
        this.config = __spreadValues(__spreadValues({}, defaultConfig), window.embedYoutubeConfig || {});
        this.scheduleUpdate;
        this.isIframeLoaded = false;
        this.globalParam = globalParamHook;
        initShadowDom(this);
      }
      // get attributi locali del component
      get videoId() {
        const rawId = this.getAttribute("video-id") || "";
        const id = normalizeVideoId(rawId);
        return encodeURIComponent(id);
      }
      get playlistId() {
        return encodeURIComponent(this.getAttribute("playlist-id") || "");
      }
      get videoTitle() {
        return this.getAttribute("video-title") || this.config.textVideoTitle;
      }
      get description() {
        return this.getAttribute("description");
      }
      get playText() {
        return this.getAttribute("play-text");
      }
      get videoStartAt() {
        return this.getAttribute("video-start-at") || this.config.videoStartAt;
      }
      get autoLoadMargin() {
        return this.getAttribute("autoload-margin") || "0px";
      }
      get posterUrl() {
        return this.getAttribute("poster-url");
      }
      get posterQuality() {
        return this.getAttribute("poster-quality") || this.config.posterQuality;
      }
      get paramList() {
        return this.getAttribute("param-list");
      }
      isYouTubeShort() {
        return this.getAttribute("short") === "" && window.matchMedia("(max-width: 40em)").matches;
      }
      // get attributi locali del component
      // has attributi locali del component
      get autoLoad() {
        return this.hasAttribute("autoload") || this.globalParam.hasAttribute("data-autoload");
      }
      get autoPlay() {
        return this.hasAttribute("autoplay") || this.globalParam.hasAttribute("data-autoplay");
      }
      get mute() {
        return this.hasAttribute("mute") || this.globalParam.hasAttribute("data-mute");
      }
      get autoPause() {
        return this.hasAttribute("autopause") || this.globalParam.hasAttribute("data-autopause");
      }
      get noCookie() {
        return this.hasAttribute("no-cookie") || this.globalParam.hasAttribute("data-no-no-cookie");
      }
      get noSchema() {
        return this.hasAttribute("no-schema") || this.globalParam.hasAttribute("data-no-schema");
      }
      get noPreconnect() {
        return this.hasAttribute("no-preconnect") || this.globalParam.hasAttribute("data-no-preconnect");
      }
      get noLazyLoad() {
        return this.hasAttribute("no-lazyload");
      }
      get posterFallback() {
        return this.hasAttribute("poster-fallback");
      }
      // has attributi locali del component
      static get observedAttributes() {
        return ["video-id", "playlist-id", "video-title", "play-text", "poster-url", "poster-fallback", "short", "mute"];
      }
      connectedCallback() {
        if (missingVideoId(this)) return;
        this.setupComponent();
        this.addEventListener("click", () => {
          this.loadIframe();
        });
        this.addEventListener("pointerover", () => {
          preloadConnection(this);
        }, {
          "once": true
        });
      }
      /**
       * The `setupComponent` sets up various properties and behaviors for a video component, including setting labels, custom posters, auto-loading iframes etc.
       */
      setupComponent() {
        const label = setLabel(this);
        this.domPlayButton.setAttribute("aria-label", label);
        this.setAttribute("title", label);
        this.domImgPoster.src = "";
        if (this.noLazyLoad) {
          this.domImgPoster.removeAttribute("loading");
        }
        if (this.posterFallback) {
          this.setPosterFallback();
        } else if (this.posterUrl) {
          this.setPosterCustom();
        } else {
          this.setPoster();
        }
        if (this.autoLoad || this.isYouTubeShort()) {
          this.autoLoadIframe();
        }
        if (this.autoPause) {
          this.autoPauseVideo();
        }
        if (!this.noSchema) {
          injectSchema(this);
        }
      }
      /**
       * The function `createIframe()` generates an iframe code for embedding a YouTube video with specified parameters and options.
       * @returns it returns a string containing an HTML `<iframe>` element with attributes.
       * The src attribute is dynamically generated based on the parameters set within the function.
       */
      createIframe() {
        const noCookieDomain = this.noCookie ? "-nocookie" : "";
        const embedTarget = this.playlistId ? `?listType=playlist&list=${this.playlistId}&` : `${this.videoId}?`;
        let videoParam;
        if (this.paramList && this.paramList !== "") {
          videoParam = this.paramList;
        } else {
          const enableApi = this.autoPlay || this.autoPause || this.isYouTubeShort() ? 1 : 0;
          const autoplay = this.autoLoad && !this.autoPlay ? 0 : 1;
          const muted = this.mute ? 1 : 0;
          const startAt = this.videoStartAt;
          videoParam = `enablejsapi=${enableApi}&autoplay=${autoplay}&start=${startAt}`;
          if (autoplay && this.autoLoad) {
            videoParam = `${videoParam}&mute=1`;
          } else {
            videoParam = `${videoParam}&mute=${muted}`;
          }
          if (this.isYouTubeShort()) {
            videoParam = `${videoParam}&loop=1&modestbranding=1&playsinline=1&rel=0&playlist=${this.videoId}`;
          }
        }
        const iframeCode = `
				<iframe title="${this.videoTitle}" credentialless allow="accelerometer;autoplay;encrypted-media;gyroscope;picture-in-picture" allowfullscreen src="https://www.youtube${noCookieDomain}.com/embed/${embedTarget}${videoParam}"></iframe>
			`;
        return iframeCode;
      }
      /**
       * The function `loadIframe` checks if an iframe is already loaded, creates and inserts an iframe if not, and dispatches a custom event once the iframe is loaded.
       */
      loadIframe() {
        if (!this.isIframeLoaded) {
          const iframeCode = this.createIframe();
          this.domContainer.insertAdjacentHTML("beforeend", iframeCode);
          this.domContainer.classList.add(this.config.activeIframeClass);
          this.isIframeLoaded = true;
          this.dispatchEvent(new CustomEvent("embedYoutubeLoaded", {
            "detail": {
              "videoId": this.videoId,
              "playlistId": this.playlistId,
              "videoTitle": this.videoTitle,
              "posterUrl": this.posterUrl
            },
            "bubbles": true,
            "cancelable": true
          }));
        }
      }
      /**
       * `autoLoadIframe` sets up an IntersectionObserver to monitor when an iframe element becomes visible in the viewport.
       * When the iframe intersects with the viewport and has not been loaded yet, it triggers `preloadConnection` and `loadIframe(true)` to load the iframe content.
       * Once the iframe is loaded, the observer stops observing the iframe element.
       */
      autoLoadIframe() {
        const options = {
          "root": null,
          "rootMargin": this.autoLoadMargin,
          "threshold": 0
        };
        const observerIframe = new IntersectionObserver((entryList, observer) => {
          entryList.forEach((entry) => {
            if (entry.isIntersecting && !this.isIframeLoaded) {
              preloadConnection(this);
              this.loadIframe(true);
              observer.unobserve(this);
            }
          });
        }, options);
        observerIframe.observe(this);
      }
      /**
       * `autoPauseVideo` uses the Intersection Observer API to automatically pause a video when it is not in the viewport.
       */
      autoPauseVideo() {
        const observerVideo = new IntersectionObserver((entryList) => {
          entryList.forEach((entry) => {
            var _a, _b;
            if (!entry.isIntersecting) {
              (_b = (_a = this.shadowRoot.querySelector("iframe")) == null ? void 0 : _a.contentWindow) == null ? void 0 : _b.postMessage('{"event":"command","func":"pauseVideo","args":""}', "*");
            }
          });
        }, {
          "threshold": 0
        });
        observerVideo.observe(this);
      }
      /**
       * The function `setPosterFallback` removes loading attribute, hides play button, and sets a custom SVG image as the poster fallback.
       */
      setPosterFallback() {
        var _a, _b;
        const svg = `
				<svg part="poster-fallback" xmlns="http://www.w3.org/2000/svg" viewBox="0 48 294 198" width="294" height="198">
					<path d="M294,48 c0-8.284-6.716-15-15-15H15 C6.716,33,0,39.716,0,48v198 c0,8.284,6.716,15,15,15h264 c8.284,0,15-6.716,15-15V48z" fill="red"/>
					<path transform="translate(0,6)" d="M124,113.134 c0-2.68,1.596-5.155,3.917-6.495 c2.32-1.34,5.263-1.34,7.583,0 l37.046,21.364 c2.32,1.34,3.771,3.815,3.771,6.495 s-1.419,5.155-3.74,6.495 l-36.999,21.364 c-1.16,0.67-2.452,1.005-3.747,1.005 s-2.755-0.335-3.915-1.005 c-2.32-1.34-3.915-3.815-3.915-6.495V113.134z" fill="white"/>
					<path transform="translate(0,-30)" d="M263.333,232H89v1 c0,4.143-3.357,7.5-7.5,7.5 S74,237.143,74,233v-1 H30.333 c-4.143,0-7.5-3.357-7.5-7.5 s3.357-7.5,7.5-7.5h44 c0-4.143,3.357-7.5,7.5-7.5 s7.5,3.357,7.5,7.5h174 c4.143,0,7.5,3.357,7.5,7.5 S267.476,232,263.333,232z" fill="white"/>
					<text x="147" y="95" fill="white" font-family="Verdana, sans-serif" font-size="18" font-weight="bold" text-anchor="middle">Play video</text>
				</svg>
			`;
        if (!this.getAttribute("poster-fallback")) {
          this.setAttribute("poster-fallback", "");
        }
        hideElem(this.domPlayButton, true);
        this.domPlayButton.setAttribute("aria-hidden", "true");
        (_a = this.domPosterContainer.querySelector("#img-webp")) == null ? void 0 : _a.remove();
        (_b = this.domPosterContainer.querySelector("#img-jpg")) == null ? void 0 : _b.remove();
        const uri = `data:image/svg+xml;charset=UTF-8,${encodeURIComponent(svg)}`;
        this.domImgPoster.src = uri;
        this.domImgPoster.removeAttribute("loading");
        this.domImgPoster.setAttribute("alt", "");
      }
      /**
       * The function `setPosterCustom` sets the `src` and `alt` attributes of an image element based on the provided `posterUrl` and `videoTitle` properties.
       */
      setPosterCustom() {
        this.domImgPoster.src = this.posterUrl;
        this.domImgPoster.onload = () => {
          if (!this.posterFallback) {
            this.domImgPoster.setAttribute("alt", this.videoTitle);
            hideElem(this.domPlayButton, false);
          }
        };
        this.domImgPoster.onerror = () => {
          if (this.posterUrl) {
            this.setPosterFallback();
          }
        };
      }
      /**
       * The `setPoster` function dynamically sets the poster image for a video element by checking for the availability of webp image and adjusting the quality accordingly.
       */
      setPoster() {
        const webpUrl = `https://i.ytimg.com/vi_webp/${this.videoId}/${this.posterQuality}.webp`;
        const jpgUrl = `https://i.ytimg.com/vi/${this.videoId}/${this.posterQuality}.jpg`;
        const img = new Image();
        img.src = webpUrl;
        img.onload = () => {
          const is404Poster = img.naturalWidth === 120 && img.naturalHeight === 90;
          if (is404Poster) {
            return this.setPosterFallback();
          }
          const sourceWebp = document.createElement("source");
          sourceWebp.id = "img-webp";
          sourceWebp.setAttribute("type", "image/webp");
          const sourceJpg = document.createElement("source");
          sourceJpg.id = "img-jpg";
          sourceJpg.setAttribute("type", "image/jpeg");
          this.domPosterContainer.prepend(sourceWebp, sourceJpg);
          this.domPosterContainer.querySelector("#img-webp").srcset = webpUrl;
          this.domPosterContainer.querySelector("#img-jpg").srcset = jpgUrl;
          this.domImgPoster.src = jpgUrl;
          hideElem(this.domPlayButton, false);
        };
      }
      /**
       * The attributeChangedCallback handles attribute changes by updating the component accordingly, including cancelling any scheduled updates and reinitializing the component.
       * @param attrname -it represents the name of the attribute that was changed on the custom element to which the callback is attached.
       * It helps you identify which attribute triggered the callback so that you can perform specific actions based on that attribute's change.
       * @param oldvalue -it represents the previous value of the attribute that was changed.
       * It is compared with the `newvalue` parameter to determine what has changed in the element's attributes. If `oldvalue` is `null`, it means that the attribute
       * @param newvalue -It  represents the new value of the attribute that triggered the callback.
       * It is the updated value of the attribute that was changed in the element. In the provided code snippet, `newvalue` is used to check if the attribute value has
       *
       * metodo nativo dei web component. serve per intercettare i cambiamenti agli attributi di un elemento personalizzato.
       */
      attributeChangedCallback(attrname, oldvalue, newvalue) {
        if (oldvalue === null || oldvalue === newvalue) return;
        if (this.scheduleUpdate) cancelAnimationFrame(this.scheduleUpdate);
        const videoId = attrname === "video-id" ? oldvalue : this.videoId;
        if (!this.noSchema && this.querySelector(`#json-${videoId}`)) {
          this.querySelector(`#json-${videoId}`).remove();
        }
        this.scheduleUpdate = requestAnimationFrame(() => {
          if (this.domContainer.classList.contains(this.config.activeIframeClass)) {
            this.domContainer.classList.remove(this.config.activeIframeClass);
            this.shadowRoot.querySelector("iframe").remove();
            this.isIframeLoaded = false;
          }
          this.setupComponent();
        });
      }
    }
    customElements.define("embed-youtube", embedYouTube);
  })();
})();
